#!/usr/bin/env bash

set -o pipefail
set -o nounset

source "$(dirname -- "$(realpath -- "${BASH_SOURCE[0]}")")/../.ez-installrc"
source "${EZ_INSTALL_HOME}/common/include.sh"

###################################################### EXTERNAL DEPENDENCIES ###

include "${EZ_INSTALL_HOME}/common/common.sh"
include "${EZ_INSTALL_HOME}/common/array.sh"
include "${EZ_INSTALL_HOME}/common/sys.sh"
include "${EZ_INSTALL_HOME}/const.sh"
include "${EZ_INSTALL_HOME}/actions.sh"
include "${EZ_INSTALL_HOME}/install/utils/pac-logger.sh"
include "${EZ_INSTALL_HOME}/install/utils/pac-transform.sh"
include "${EZ_INSTALL_HOME}/install/utils/pac-validate.sh"
include "${EZ_INSTALL_HOME}/install/utils/pac-install.sh"
include "${EZ_INSTALL_HOME}/install/install-utils/install.sh"
include "${EZ_INSTALL_HOME}/install/common.sh"
include "${EZ_INSTALL_HOME}/generate/utils/generate.sh"

################################################## CONSTANT GLOBAL VARIABLES ###

readonly EZ_INSTALL_VERSION="0.3 BETA"
readonly SCRIPT_ARGS="$@"
readonly SCRIPT_ARGS_NUM=$#

############################################################### FLAG OPTIONS ###


# TODO: Separate manual from usage. Also, auto generate exit codes.
function usage() {
  cat << EOF
${SCRIPT_NAME} ${EZ_INSTALL_VERSION}

COMMAND NAME:

  ${SCRIPT_NAME} - Ez package installer.

INSTALL USAGE:

  ez ${SCRIPT_NAME} [options] package1 package2 ...

INSTALL OPTIONS:

  Flag option with arguments

    --package-dir   -D    Directory to search packages from.
                          Global default=\$PACKAGE_ROOT_DIR.
                          Local default=\$LOCAL_PACKAGE_ROOT_DIR.
    --destination   -o    Package output directory (for curl, wget, etc.).
                          default=\$HOME/Downloads.

  Flag option switches

    --generate         -c    Generate package(s) instead of install.
    --force            -f    Force install/reinstall packages.
    --no-force         -F    Do not force install/reinstall packages.
    --recurse          -r    Recursively install package dependencies.
    --no-recurse       -R    Prevent recursive package dependency installation.
    --as-root          -s    Run package manager as root (sudo).
    --no-root          -S    Prevent running package manager as root (sudo).
    --allow-dep-fail   -w    Continue root package installation on dependency
                             failure.
    --no-dep-fail      -W    Do not allow package installation dependency
                             failure.

    --skip-generate    -C    Skip auto generate prompt. When used with -c,
                             --generate, generate non-interactive base template.
    --json             -j    Parse package data as json.
    --quiet            -q    Suppress standard output. LOG_DEBUG_LEVEL=3.
    --debug            -x    Debug mode (print all log levels). LOG_DEBUG_LEVEL=7.
    --skip-confirm     -y    Skip confirmation.
    --no-colors        -z    Disable output colors.
    --help             -h    Print usage.
    --version          -V    Print install version.

INSTALL IN-LINE OPTIONS:

  #force          Force package installation.
  #noforce        Do not force package installation.
  #root           Give package installation root privileges.
  #noroot         Give no package installation root privileges.
  #dep            Install package recursively.
  #nodep          Do not install package dependencies.
  #allowdepfail   Allow package dependency installation failure.
  #nodepfail      Do not allow package dependency installation failure.

  In-line options \`#opt\` supercedes the flag options but only for the specific
  package.

  e.g., \`ez $SCRIPT_NAME -S package1#noroot package2 package3\` will try to install
  all packages with root privileges except \`package1\`

  e.g., \`ez $SCRIPT_NAME package1#root package2#nodep package3#root,nodep\` will try
  to install \`package1\` as root, \`package2\` without its dependencies, and
  \`package3\` as root and without its dependencies.

INSTALL HOOKS:

  Pre Installation

    \`${SCRIPT_NAME}\` will automatically try to source <package>.pre first then
    <package>.<package_manager>.pre from either \$LOCAL_PACKAGE_ROOT_DIR and
    \$PACKAGE_ROOT_DIR before package installation. \$LOCAL_PACKAGE_DIR priority.
    Best place to download dependencies or executing pre installation commands.

  Post Installation

    \`${SCRIPT_NAME}\` will automatically try to source <package>.post first then
    <package>.<package_manager>.post from either \$LOCAL_PACKAGE_ROOT_DIR and
    \$PACKAGE_ROOT_DIR after package installation. \$LOCAL_PACKAGE_DIR priority.
    Best place for cleaning up files or executing post installation commands.

EOF
}


function handle_args() {
  # Install configs
  [[ -z "${SKIP_CONFIRM+x}" ]]    && SKIP_CONFIRM=false
  [[ -z "${VERBOSE+x}" ]]         && VERBOSE=true
  [[ -z "${DEBUG+x}" ]]           && DEBUG=false
  [[ -z "${LOG_DEBUG_LEVEL+x}" ]] && LOG_DEBUG_LEVEL=4
  [[ -z "${ENABLE_COLORS+x}" ]]   && ENABLE_COLORS=true
  [[ -z "${SKIP_GENERATE+x}" ]]   && SKIP_GENERATE=false
  [[ -z "${JSON+x}" ]]            && JSON=false
  [[ -z "${GENERATE+x}" ]]        && GENERATE=false
  [[ -z "${DESTINATION+x}" ]]     && DESTINATION="${HOME}/Downloads"

  # Package configs
  [[ -z "${FORCE+x}" ]]          && FORCE=false
  [[ -z "${RECURSIVE+x}" ]]      && RECURSIVE=true
  [[ -z "${AS_ROOT+x}" ]]        && AS_ROOT=false
  [[ -z "${ALLOW_DEP_FAIL+x}" ]] && ALLOW_DEP_FAIL=false
  CONFIG=""

  #== parse options ==#
  # Ref: https://www.uxora.com/unix/shell-script/22-handle-long-options-with-getopts

  # Especially useful when relaying script args with group quoted OPTARG
  eval set -- ${@:-}

  local -A long_opts_map
  long_opts_map=(
    ['package-dir']=D
    ['generate']=c
    ['skip-generate']=C
    ['json']=j
    ['destination']=o
    ['quiet']=q
    ['force']=f
    ['no-force']=F
    ['recurse']=r
    ['no-recurse']=R
    ['as-root']=s
    ['no-root']=S
    ['allow-dep-fail']=w
    ['no-dep-fail']=W
    ['version']=V
    ['debug']=x
    ['skip-confirm']=y
    ['no-colors']=z
    ['help']=h
  )

  local script_opts=':D:o:cCfFjqrRsSwWxyzhV-:'
  local script_args="$@"
  local script_args_num=$#

  local OPTIND=1
  while getopts ${script_opts} OPTION; do
    #== translate long options to short ==#
    if [[ "x$OPTION" == "x-" ]]; then
      LONG_OPTION=$OPTARG
      LONG_OPTARG=$(echo $LONG_OPTION | grep "=" | cut -d'=' -f2)
      LONG_OPTIND=-1

      [[ "x$LONG_OPTARG" = "x" ]] && LONG_OPTIND=$OPTIND || LONG_OPTION=$(echo $OPTARG | cut -d'=' -f1)
      [[ $LONG_OPTIND -ne -1 ]] && eval LONG_OPTARG="\$$LONG_OPTIND"

      OPTION=${long_opts_map[$LONG_OPTION]}
      [[ "x$OPTION" = "x" ]] &&  OPTION="?" OPTARG="-$LONG_OPTION"

      if [[ $( echo "${script_opts}" | grep -c "${OPTION}:" ) -eq 1 ]]; then
        # OPTION followed by another option instead of argument will be omitted.
        if [[ "x${LONG_OPTARG}" = "x" ]] || [[ "${LONG_OPTARG}" = -* ]]; then
          OPTION=":" OPTARG="-$LONG_OPTION"
        else
          OPTARG="$LONG_OPTARG";
          if [[ $LONG_OPTIND -ne -1 ]]; then
            [[ $OPTIND -le $script_args_num ]] && OPTIND=$(( OPTIND+1 ))
            shift $OPTIND
            OPTIND=1
          fi
        fi
      fi
    fi

    # OPTION followed by another option instead of argument will be omitted.
    if [[ "x${OPTION}" != "x:" ]] && [[ "x${OPTION}" != "x?" ]] && [[ "${OPTARG:-}" = -* ]]; then
      OPTARG="$OPTION" OPTION=":"
    fi

    #== manage options ==#
    case "$OPTION" in
      D) LOCAL_PACKAGE_ROOT_DIR="${OPTARG}" ;;
      o) DESTINATION="${OPTARG}" ;;
      f) FORCE=true;           CONFIG="${CONFIG} -${OPTION}" ;;
      F) FORCE=false;          CONFIG="${CONFIG} -${OPTION}" ;;
      r) RECURSIVE=true;       CONFIG="${CONFIG} -${OPTION}" ;;
      R) RECURSIVE=false;      CONFIG="${CONFIG} -${OPTION}" ;;
      s) AS_ROOT=true;         CONFIG="${CONFIG} -${OPTION}" ;;
      S) AS_ROOT=false;        CONFIG="${CONFIG} -${OPTION}" ;;
      w) ALLOW_DEP_FAIL=true;  CONFIG="${CONFIG} -${OPTION}" ;;
      W) ALLOW_DEP_FAIL=false; CONFIG="${CONFIG} -${OPTION}" ;;
      c) GENERATE=true ;;
      C) SKIP_GENERATE=true ;;
      y) SKIP_CONFIRM=true ;;
      q) VERBOSE=false; LOG_DEBUG_LEVEL=3 ;;
      x) DEBUG=true; LOG_DEBUG_LEVEL=7 ;;
      j)
        JSON=true
        error "JSON data parsing is currently not supported"
        exit $BASH_EX_GENERAL
        ;;
      z)
        ENABLE_COLORS=false
        include "${EZ_INSTALL_HOME}/common/colors.sh"
        ;;
      h) usage; exit $BASH_EX_OK ;;
      V) echo "${SCRIPT_NAME} ${EZ_INSTALL_VERSION}"; exit $BASH_EX_OK ;;
      \?) echo "An invalid option has been entered: ${OPTARG:-}" ;;
      :) echo "The additional argument for option ${OPTARG:-} was omitted." ;;
      *)
        usage
        error "Invalid flag option(s)"
        exit $BASH_SYS_EX_USAGE
    esac
  done
  shift $((${OPTIND} - 1))


  if [[ -p /dev/stdin ]]; then
    usage
    error "Piped arguments not supported"
    exit $BASH_SYS_EX_USAGE
  fi

  if [[ ! -t 0 && ! -p /dev/stdin ]]; then
    usage
    error "Stdin redirection not supported"
    exit $BASH_SYS_EX_USAGE
  fi

  # Arguments from terminal into $PACKAGES
  if [[ -t 0 ]]; then
    if [[ -n "${@+x}" ]]; then
      IFS=" " read -a PACKAGES <<< "${@}"
      readonly PACKAGES
    else
      usage
      error "No package(s) provided"
      exit $BASH_SYS_EX_USAGE
    fi
  fi

  local res=0

  if [[ ! -d "${DESTINATION}" ]]; then
    if execlog "mkdir -p '${DESTINATION}'"; then
      ok "'${DESTINATION}' directory created"
    else
      res=$?
      error "'${DESTINATION}' creation failed"
      exit $BASH_SYS_EX_CANTCREAT
    fi
  fi

  resolve_package_dir

  return $BASH_EX_OK
}

############################################################# MAIN EXECUTION ###

function _main () {
  local res=0

  script_vars
  handle_args "$@"
  res=$?
  [[ $res -ne $BASH_EX_OK ]] && return $res

  local -a packages=( ${PACKAGES[@]} )
  array_unique packages

  if $GENERATE; then
    i_batch_generate_template ${packages[@]}
  else
    ! ${DEBUG} && echo -e "About to install the following packages:\n"

    # TODO: Fully support json configs
    if ! $JSON; then
      validate_packages ${CONFIG} -- ${packages[@]}
      res=$?; [[ ${res} -ne $BASH_EX_OK ]] && return $res

      $DEBUG && $VERBOSE && echo "Jsonifying..."
      pac_array_jsonify ${CONFIG} -- packages
    fi

    if $DEBUG && $VERBOSE || $JSON; then
      for package in ${packages[@]}; do
        echo "${package}" | ${EZ_DEP_JQ} -r ".package"
      done
    fi

    confirm "\nYou are about to install the package(s) above. Continue? (Y/y): " \
      || exit $BASH_EX_GENERAL

    warning "Installation in progress... Do not interrupt!"

    pac_batch_json_install "${packages[@]}"
    res=$?; [[ $res -ne $BASH_EX_OK ]] && exit $res

    [[ -n "${packages+x}" ]] && pac_report
  fi

  finish "Finished!"
  return $BASH_EX_OK
}


res=0
_main "${SCRIPT_ARGS}"
res=$?

unset EZ_DOWNLOADS_DIR
unset SKIP_CONFIRM
unset VERBOSE
unset DEBUG
unset LOG_DEBUG_LEVEL
unset ENABLE_COLORS
unset GENERATE
unset ALLOW_DEP_FAIL
unset FORCE
unset RECURSIVE
unset ALLOW_DEP_FAIL
unset AS_ROOT
unset SKIP_GENERATE
unset JSON
unset DESTINATION
unset PACKAGE_DIR
unset PACKAGES

exit $res
